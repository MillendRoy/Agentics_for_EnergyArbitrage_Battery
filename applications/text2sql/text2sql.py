import os
from typing import Optional,Union
from pydantic import BaseModel, ConfigDict, Field
from dotenv import find_dotenv, load_dotenv
import time
from mcp import StdioServerParameters # For Stdio Server
import asyncio
import sys
from pathlib import Path
import random
sys.path.append(str(Path(__file__).resolve().parent))
from utils import get_schema, async_execute_sql, evaluate_execution_accuracy
from crewai.tools import tool
from agentics import AG

from crewai_tools import MCPServerAdapter
from agentics import AG

load_dotenv(find_dotenv())
begin_time=time.time()

class Text2sqlQuestion(BaseModel): 
    question: Optional[str] =None
    db_id: Optional[str] =None
    sql: Optional[str] =None
    evidence: Optional[Union[str,list[str]]]=None
    reasoning_type: Optional[str] =None
    commonsense_knowledge: Optional[str] =None
    schema: Optional[str] = None
    generated_query: Optional[str] =Field(None, description="The query generated by AI")
    system_output_df: Optional[str] = None
    gt_output_df: Optional[str] = None

async def get_schema_map(state:Text2sqlQuestion)-> Text2sqlQuestion:
    schema_path = os.path.join(os.getenv("SQL_DB_PATH"), 
                            state.db_id,state.db_id+".sqlite" )
    state.schema=str(get_schema(schema_path))
    print(state.db_id)
    return state

## Define a Crew AI tool to get news for a given date using the DDGS search engine
@tool("execute_sql_query")
async def execute_sql_query(sql_query:str, db_id:str)-> str:
    """Execute a SQL query against the target db and return the execution results (error or json dataframe)"""
    schema_path = os.path.join(os.getenv("SQL_DB_PATH"), 
                            db_id,db_id+".sqlite" )
    system_output_df= await async_execute_sql(sql_query, schema_path)
    return system_output_df 


async def execute_query_map(state:Text2sqlQuestion)-> Text2sqlQuestion:
    schema_path = os.path.join(os.getenv("SQL_DB_PATH"), 
                            state.db_id,state.db_id+".sqlite" )
    state.system_output_df= await async_execute_sql(state.generated_query, schema_path)
    state.gt_output_df= await async_execute_sql(state.sql, schema_path)
    return state

def get_training_data(training_dataset:str, n_shots=3) -> AG:
    training = AG.from_jsonl(training_dataset,jsonl=False)
    training = training.rebind_atype(Text2sqlQuestion)
    few_shots= AG(atype=Text2sqlQuestion)
    for i in range(n_shots):
        selected_question = random.choice(training.states)
        selected_question.generated_query = selected_question.sql
        few_shots.states.append(selected_question)
    return few_shots


async def execute_questions(test:AG, few_shots_path:str = None):

    training = AG(atype=Text2sqlQuestion)
    if few_shots_path:
        training = get_training_data(few_shots_path)
    test.llm=AG.get_llm_provider("watsonx")
    test.reasoning=False
    test.tools=[execute_sql_query]
    test.max_iter=10
    ## add training data
    test.states= training.states+test.states
    test= await test.amap(get_schema_map)
    test.verbose_agent=True


    test = await test.self_transduction(
        ["question","db_id", "schema","evidence"], 
        ["generated_query"], 
        instructions="""Generate a SQL query from the input question 
        and target db schema taking into account the provided evidence.""")


    test= await test.amap(execute_query_map)
    print(f"task executed in {time.time() - begin_time} seconds")
    test.states=test.states[len(training.states):]
    print(evaluate_execution_accuracy(test))
    return test


async def run_evaluation_benchmark(path: str="/Users/gliozzo/Data/Text2SQL/bird/dev_20240627.jsonl",
                       max_rows: int = 10,
                       few_shots_path: str = None):
    test = AG.from_jsonl("/Users/gliozzo/Data/Text2SQL/bird/dev_20240627.jsonl", 
                  jsonl=True,
                  atype=Text2sqlQuestion,
                  max_rows=max_rows)
    return await execute_questions(test, few_shots_path=few_shots_path)
    


asyncio.run(run_evaluation_benchmark(max_rows=10))

# print( asyncio.run(execute_questions(
#     AG(atype=Text2sqlQuestion, states=[Text2sqlQuestion(
#         question= "What is the highest eligible free rate for K-12 students in the schools in Alameda County?", 
#         db_id = "california_schools")]))))

# test = AG.from_jsonl("/Users/gliozzo/Data/Text2SQL/bird/dev_20240627.jsonl", 
                     

#                     jsonl=True, 
#                     atype=Text2sqlQuestion,
#                     max_rows=10)
# asyncio.run(text2sql_task(test, 
#                           few_shots_path="/Users/gliozzo/Data/Text2SQL/bird/train/train.json"))

